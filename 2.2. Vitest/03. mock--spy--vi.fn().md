# Принципы изолированного тестирования.

1. Объект для тестирования - функция или vue-копмонент.
   Vue-копмонент перед тестированием поднимается - собирается в функцию.
2. Часто объект тестирования имеет внешние импортируемые зависимости.
   На эти зависимости мы ставим заглушки.
3. 
   Дополнительно, через методы, которыми обладают заглушки,
   мы можем отследить использование заглушенных зависимостей.
4. Мы имеем:



# 1. mocking - vi.mock(), заместитель.
Target: у експортирующего файла подменяем то, что модуль экспортирует.
Нативная функция, прописанная в файле, даже НЕ запускается.

Для формирования заглушки нам требуется указать:
- ПУТЬ от файла с vi.mock() до експортирующего файла,
- колбек, который возвращает фэйковый экспорт файла.

НИЧЕГО полезного дополнительно, кроме подмены возврата, - мы практически НЕ имеем.



# 2. spysing - vi.spy(), транформатор.
Мы имеем дело с ООП, поэтому минимальной структурной единицей каких-либо ДАННЫХ является объект.
На методы и поля этой "минимальной структурной единицы" мы дополнительно подвешиваем spy-обработчики. 

Target: поля объекта.
При импорте - продолжают срабатывать обращения к нативным полям объекта.
Нативные методы объекта - продолжают запускаться.

Для формирования трансформатора нам требуется:
- иметь способность обратиться к объекту, ПО СНОСКЕ,
- обозначить поле объекта, на которое мы желаем подвесить spy-обработчики,
- профилировать spy-обработчики по get/set-типу, что указываем третим аргументом в vi.spy().

Через spy-обработчики мы МОЖЕМ:
- подменить return,
- перезадать return еще раз,
- отследить:
  - toHaveBeenCalled()
  - какие аргументы были переданы этому методу,
  - toHaveReturnedWith()




# 3. mimicrator - vi.fn(), слуга двух господ.
- самодостаточная функция, способная принимать и обрабатывать аргументы, 
but которая ДОПОЛНИТЕЛЬНО имеет spy-методы на саму себя.
- посредством этих методов мы можем отследить, что с этой функцией происходит.


Через spy-обработчики мы можем:
- перезадать тело функции и ее return,
- отследить:
  - toHaveBeenCalled()
  - toHaveReturnedWith()

Common using:
Если у нас есть функция, в аргумент которой посылается тоже функция,
то мы можем запустить тестируюемую супер-функцию, послав в роли аргумента vi.fn()-мимикратора.

